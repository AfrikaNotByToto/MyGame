"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCalendarType = exports.getMatrix = exports.canSelectDate = exports.getInRange = exports.getSideInRange = exports.getSideForHovered = exports.getSideForSelected = exports.isSelectProcess = exports.isValueUpdate = exports.isSameDay = exports.isDayInRage = exports.getSortedValues = exports.isSelectedYear = exports.isCurrentYear = exports.isSelectedMonth = exports.isCurrentMonth = exports.isSelectedDay = exports.IsCurrentDay = exports.getDateFromNow = exports.getDateFromValue = exports.getPrevDate = exports.getNextDate = exports.getStartYear = exports.getOffsetDayInWeek = exports.getDaysInMonth = exports.MONTH_NAMES = exports.SHORT_MONTH_NAME = exports.FULL_DAY_NAMES = exports.SHORT_DAY_NAMES = exports.YEAR_RENDER_COUNT = exports.ROW_STEP = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var ROW_STEP = 6;
exports.ROW_STEP = ROW_STEP;
var YEAR_RENDER_COUNT = 12;
exports.YEAR_RENDER_COUNT = YEAR_RENDER_COUNT;
var SHORT_DAY_NAMES = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
exports.SHORT_DAY_NAMES = SHORT_DAY_NAMES;
var FULL_DAY_NAMES = {
  Пн: 'Понедельник',
  Вт: 'Вторник',
  Ср: 'Среда',
  Чт: 'Четверг',
  Пт: 'Пятница',
  Сб: 'Суббота',
  Вс: 'Воскресенье'
};
exports.FULL_DAY_NAMES = FULL_DAY_NAMES;
var SHORT_MONTH_NAME = ['Янв', 'Фев', 'Март', 'Апр', 'Май', 'Июнь', 'Июль', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
exports.SHORT_MONTH_NAME = SHORT_MONTH_NAME;
var MONTH_NAMES = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
exports.MONTH_NAMES = MONTH_NAMES;

var getDaysInMonth = function getDaysInMonth(monthIndex, year) {
  return new Date(year, monthIndex + 1, 0).getDate();
};

exports.getDaysInMonth = getDaysInMonth;

var getOffsetDayInWeek = function getOffsetDayInWeek(monthIndex, year) {
  return (new Date(year, monthIndex).getDay() || 7) - 1;
};

exports.getOffsetDayInWeek = getOffsetDayInWeek;

var getStartYear = function getStartYear(year) {
  return Math.trunc((year - 1) * 0.1) * 10 - 1;
};

exports.getStartYear = getStartYear;

var getNextDate = function getNextDate(currentYear, currentMonth) {
  return currentMonth + 1 === MONTH_NAMES.length ? [currentYear + 1, 0] : [currentYear, currentMonth + 1];
};

exports.getNextDate = getNextDate;

var getPrevDate = function getPrevDate(currentYear, currentMonth) {
  return currentMonth - 1 < 0 ? [currentYear - 1, 11] : [currentYear, currentMonth - 1];
};

exports.getPrevDate = getPrevDate;

var getDateFromValue = function getDateFromValue(date) {
  var state = date || new Date();
  return {
    day: date !== undefined ? state.getDate() : 0,
    monthIndex: state.getMonth(),
    year: state.getFullYear()
  };
};

exports.getDateFromValue = getDateFromValue;

var getDateFromNow = function getDateFromNow() {
  var nowDate = new Date();
  return {
    day: nowDate.getDate(),
    monthIndex: nowDate.getMonth(),
    year: nowDate.getFullYear()
  };
};

exports.getDateFromNow = getDateFromNow;

var IsCurrentDay = function IsCurrentDay(date, currentDay) {
  var _getDateFromNow = getDateFromNow(),
      day = _getDateFromNow.day,
      currentMonthIndex = _getDateFromNow.monthIndex,
      currentYear = _getDateFromNow.year;

  return day === currentDay && date.monthIndex === currentMonthIndex && date.year === currentYear;
};

exports.IsCurrentDay = IsCurrentDay;

var isSelectedDay = function isSelectedDay(date, currentDay, value) {
  if (!value) {
    return false;
  }

  var _getDateFromValue = getDateFromValue(value),
      day = _getDateFromValue.day,
      monthIndex = _getDateFromValue.monthIndex,
      year = _getDateFromValue.year;

  return day === currentDay && date.monthIndex === monthIndex && date.year === year;
};

exports.isSelectedDay = isSelectedDay;

var isCurrentMonth = function isCurrentMonth(date, monthIndex) {
  var _getDateFromNow2 = getDateFromNow(),
      currentMonthIndex = _getDateFromNow2.monthIndex,
      currentYear = _getDateFromNow2.year;

  return monthIndex === currentMonthIndex && date.year === currentYear;
};

exports.isCurrentMonth = isCurrentMonth;

var isSelectedMonth = function isSelectedMonth(date, monthIndex) {
  return date.monthIndex === monthIndex;
};

exports.isSelectedMonth = isSelectedMonth;

var isCurrentYear = function isCurrentYear(year) {
  var _getDateFromNow3 = getDateFromNow(),
      currentYear = _getDateFromNow3.year;

  return year === currentYear;
};

exports.isCurrentYear = isCurrentYear;

var isSelectedYear = function isSelectedYear(date, year) {
  return date.year === year;
};

exports.isSelectedYear = isSelectedYear;

var getSortedValues = function getSortedValues(values) {
  return values.sort(function (start, end) {
    if (!start || !end) {
      return -1;
    }

    return start.getTime() - end.getTime();
  });
};

exports.getSortedValues = getSortedValues;

var isDayInRage = function isDayInRage(year, monthIndex, currentDay, values) {
  var _getSortedValues = getSortedValues(values),
      _getSortedValues2 = _slicedToArray(_getSortedValues, 2),
      startValue = _getSortedValues2[0],
      endValue = _getSortedValues2[1];

  if (!endValue) {
    return false;
  }

  var day = new Date(year, monthIndex, currentDay);
  return startValue && startValue <= day && day <= endValue;
};

exports.isDayInRage = isDayInRage;

var isSameDay = function isSameDay(firstDate, secondDate) {
  return secondDate && firstDate.day === secondDate.day && firstDate.monthIndex === secondDate.monthIndex && firstDate.year === secondDate.year;
};

exports.isSameDay = isSameDay;

var isValueUpdate = function isValueUpdate(value, prevValue) {
  if (!Array.isArray(value) && !Array.isArray(prevValue)) {
    return (prevValue === null || prevValue === void 0 ? void 0 : prevValue.getTime()) !== (value === null || value === void 0 ? void 0 : value.getTime());
  }

  if (Array.isArray(value) && Array.isArray(prevValue)) {
    var _prevValue$, _value$, _prevValue$2, _value$2;

    return ((_prevValue$ = prevValue[0]) === null || _prevValue$ === void 0 ? void 0 : _prevValue$.getTime()) !== ((_value$ = value[0]) === null || _value$ === void 0 ? void 0 : _value$.getTime()) || ((_prevValue$2 = prevValue[1]) === null || _prevValue$2 === void 0 ? void 0 : _prevValue$2.getTime()) !== ((_value$2 = value[1]) === null || _value$2 === void 0 ? void 0 : _value$2.getTime());
  }

  return false;
};
/**
 * Метод проверяет, находится ли календарь в режиме выбора второго значения.
 */


exports.isValueUpdate = isValueUpdate;

var isSelectProcess = function isSelectProcess(array) {
  return Array.isArray(array) && !array[1];
};
/**
 * Метод возвращает сторону, когда выбор второго значения диапазона завершён.
 */


exports.isSelectProcess = isSelectProcess;

var getSideForSelected = function getSideForSelected(date, startValue, endValue) {
  var currentDateTime = new Date(date.year, date.monthIndex, date.day).getTime();
  var startValueTime = startValue.getTime();
  var endValueTime = endValue.getTime();

  if (currentDateTime === startValueTime) {
    return 'right';
  }

  if (currentDateTime === endValueTime) {
    return 'left';
  }

  return undefined;
};
/**
 * Метод возвращает сторону, во время выбора второго значения диапазона.
 */


exports.getSideForSelected = getSideForSelected;

var getSideForHovered = function getSideForHovered(date, hoveredDay, startValue, isSelected) {
  var dateHover = new Date(hoveredDay.year, hoveredDay.monthIndex, hoveredDay.day);
  var isHovered = isSameDay(date, hoveredDay);

  if (isSelected && startValue > dateHover || isHovered && startValue < dateHover) {
    return 'left';
  }

  if (isSelected && startValue < dateHover || isHovered && startValue > dateHover) {
    return 'right';
  }

  return undefined;
};
/**
 * Метод возвращает сторону, с которой нужно отрисовать направление полоски диапазона.
 */


exports.getSideForHovered = getSideForHovered;

var getSideInRange = function getSideInRange(value, date, hoveredDay, isSelected) {
  if (!Array.isArray(value)) {
    return undefined;
  }

  var _value = _slicedToArray(value, 2),
      startValue = _value[0],
      endValue = _value[1];

  if (startValue && isSelected && endValue) {
    return getSideForSelected(date, startValue, endValue);
  }

  if (startValue && hoveredDay) {
    return getSideForHovered(date, hoveredDay, startValue, isSelected);
  }

  return undefined;
};
/**
 * Метод проверяет, находится ли выбранный день в диапазоне.
 */


exports.getSideInRange = getSideInRange;

var getInRange = function getInRange(value, date, hoveredDay, inRange) {
  if (!isSelectProcess(value) || !hoveredDay) {
    return inRange;
  }

  var dateSelected = value[0];
  var dateHover = new Date(hoveredDay.year, hoveredDay.monthIndex, hoveredDay.day);
  var dateCurrent = new Date(date.year, date.monthIndex, date.day);

  if (dateSelected < dateCurrent && dateCurrent < dateHover || dateSelected > dateCurrent && dateCurrent > dateHover) {
    return true;
  }

  return inRange;
};
/**
 * Метод проверяет, можно ли выбрать день.
 */


exports.getInRange = getInRange;

var canSelectDate = function canSelectDate(_ref, value, disabledList) {
  var year = _ref.year,
      monthIndex = _ref.monthIndex,
      day = _ref.day;

  if (!isSelectProcess(value)) {
    return true;
  }

  var hoverDate = new Date(year, monthIndex, day);

  var _value2 = _slicedToArray(value, 1),
      startDate = _value2[0];

  if ((hoverDate === null || hoverDate === void 0 ? void 0 : hoverDate.getTime()) === (startDate === null || startDate === void 0 ? void 0 : startDate.getTime())) {
    return false;
  }

  if (!(disabledList !== null && disabledList !== void 0 && disabledList.length)) {
    return true;
  }

  var offDisabledRange = disabledList.some(function (_ref2) {
    var date = _ref2.date;
    return startDate < date && date < hoverDate || startDate > date && date > hoverDate;
  });
  return !offDisabledRange;
};
/**
 * Метод для получения двумерного массива и возвращения выбранного элемента.
 */


exports.canSelectDate = canSelectDate;

var getMatrix = function getMatrix(items) {
  var rowSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;

  var newItems = _toConsumableArray(items);

  var selected;
  var result = newItems.reduce(function (acc, item, index) {
    if (index % rowSize === 0) {
      acc.push([]);
    }

    acc[acc.length - 1].push(item);

    if (item.isSelected) {
      selected = [acc.length - 1, index % rowSize];
    }

    return acc;
  }, []);
  return [result, selected];
};

exports.getMatrix = getMatrix;

var getCalendarType = function getCalendarType(type) {
  switch (type) {
    case 'Months':
      return 'год';

    case 'Years':
      return 'период';

    default:
      return 'месяц';
  }
};

exports.getCalendarType = getCalendarType;